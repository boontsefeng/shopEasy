package com.shopeasy.shopeasy.dao;

import com.shopeasy.shopeasy.model.RegistrationKey;
import com.shopeasy.shopeasy.util.DBUtil;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Data Access Object for RegistrationKey entity
 */
public class RegistrationKeyDAO {
    private Connection conn;
    
    public RegistrationKeyDAO(){
    try{
        conn = DBUtil.getConnection();
        }catch(SQLException e){
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Generate a new registration key
     * @param role Role for the key (manager, staff)
     * @param generatedBy User ID of the manager who generated the key
     * @param validDays Number of days the key will be valid
     * @return The generated key value if successful, null otherwise
     */
    public String generateKey(String role, int generatedBy, int validDays) {
        String keyValue = UUID.randomUUID().toString().replace("-", "");
        String sql = "INSERT INTO registration_keys (key_value, role, is_used, generated_by, expires_at) VALUES (?, ?, 0, ?, IF(? > 0, DATE_ADD(NOW(), INTERVAL ? DAY), '2030-12-31 23:59:59'))";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, keyValue);
            stmt.setString(2, role);
            stmt.setInt(3, generatedBy);
            stmt.setInt(4, validDays); // First use: for the IF condition
            stmt.setInt(5, validDays); // Second use: for the INTERVAL
            
            int affectedRows = stmt.executeUpdate();
            if (affectedRows > 0) {
                return keyValue;
            }
        } catch (SQLException e) {
            System.err.println("Error generating registration key: " + e.getMessage());
            e.printStackTrace();
        }
        
        return null;
    }
    
    /**
     * Validate a registration key
     * @param keyValue Key value to validate
     * @return RegistrationKey object if valid, null otherwise
     */
    public RegistrationKey validateKey(String keyValue) {
        // Note: The default expiration date '2030-12-31 23:59:59' will pass the expires_at > NOW() check until that date
        String sql = "SELECT * FROM registration_keys WHERE key_value = ? AND is_used = 0 AND expires_at > NOW()";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, keyValue);
            
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return extractKeyFromResultSet(rs);
                }
            }
        } catch (SQLException e) {
            System.err.println("Error validating registration key: " + e.getMessage());
            e.printStackTrace();
        }
        
        return null;
    }
    
    /**
     * Mark a key as used
     * @param keyValue Key value to mark as used
     * @return true if successful, false otherwise
     */
    public boolean markKeyAsUsed(String keyValue) {
        String sql = "UPDATE registration_keys SET is_used = 1 WHERE key_value = ?";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, keyValue);
            
            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            System.err.println("Error marking key as used: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Get all active keys generated by a manager
     * @param managerId Manager user ID
     * @return List of active registration keys
     */
    public List<RegistrationKey> getActiveKeysByManager(int managerId) {
        List<RegistrationKey> keys = new ArrayList<>();
        // This will include keys with the default '2030-12-31 23:59:59' expiration date
        String sql = "SELECT * FROM registration_keys WHERE generated_by = ? AND is_used = 0 AND expires_at > NOW() ORDER BY expires_at ASC";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, managerId);
            
            try (ResultSet rs = stmt.executeQuery()) {
                while (rs.next()) {
                    keys.add(extractKeyFromResultSet(rs));
                }
            }
        } catch (SQLException e) {
            System.err.println("Error getting active keys by manager: " + e.getMessage());
            e.printStackTrace();
        }
        
        return keys;
    }
    
    /**
     * Delete an unused key
     * @param keyId Key ID to delete
     * @param managerId Manager user ID (for security - only the manager who created the key can delete it)
     * @return true if deletion successful, false otherwise
     */
    public boolean deleteKey(int keyId, int managerId) {
        String sql = "DELETE FROM registration_keys WHERE key_id = ? AND generated_by = ? AND is_used = 0";
        
        try (PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, keyId);
            stmt.setInt(2, managerId);
            
            int affectedRows = stmt.executeUpdate();
            return affectedRows > 0;
        } catch (SQLException e) {
            System.err.println("Error deleting registration key: " + e.getMessage());
            e.printStackTrace();
            return false;
        }
    }
    
    /**
     * Helper method to extract RegistrationKey from ResultSet
     * @param rs ResultSet
     * @return RegistrationKey object
     * @throws SQLException if a database access error occurs
     */
    private RegistrationKey extractKeyFromResultSet(ResultSet rs) throws SQLException {
        RegistrationKey key = new RegistrationKey();
        key.setKeyId(rs.getInt("key_id"));
        key.setKeyValue(rs.getString("key_value"));
        key.setRole(rs.getString("role"));
        key.setUsed(rs.getBoolean("is_used"));
        key.setGeneratedBy(rs.getInt("generated_by"));
        key.setCreatedAt(rs.getTimestamp("created_at"));
        key.setExpiresAt(rs.getTimestamp("expires_at"));
        return key;
    }
}